<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Meeting Room Scheduler (Firebase)</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --text: #111827;
      --card: #ffffff;
      --muted: #6b7280;
      --border: #e5e7eb;
      --ok-bg: #ecfdf5;
      --ok-border: #d1fae5;
      --busy-bg: #fef2f2;
      --busy-border: #fee2e2;
      --primary: #ffcc00;   /* Penske Yellow */
      --primary-text: #003b5c; /* Penske Navy */
      --btn-text: #111827;
    }
    .dark {
      --bg: #0b1020;
      --text: #e6e7ea;
      --card: #121a2f;
      --muted: #a7b0c0;
      --border: #25304a;
      --ok-bg: #0f2a21;
      --ok-border: #1f4a3b;
      --busy-bg: #2a1414;
      --busy-border: #4a1f1f;
      --primary: #ffcc00;
      --primary-text: #ffcc00;
      --btn-text: #0b1020;
    }

    * { box-sizing: border-box; }
    body { margin: 0; padding: 24px; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .container { max-width: 1100px; margin: 0 auto; }

    /* Header */
    .appbar { display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-bottom: 16px; padding: 12px 16px; border-radius: 16px; background: var(--card); border: 1px solid var(--border); }
    .brand { display: flex; align-items: center; gap: 12px; }
    .logo { width: 110px; height: 28px; display: inline-flex; align-items: center; justify-content: center; font-weight: 800; letter-spacing: .5px; background: var(--primary); color: var(--primary-text); border-radius: 6px; }
    .title { font-size: 20px; font-weight: 700; }
    .actions { display: flex; gap: 10px; align-items: center; }

    /* Cards & controls */
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 4px 18px rgba(0,0,0,.04); padding: 16px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); align-items: center; }
    label { font-size: 13px; color: var(--muted); }
    input, select, button { font-size: 14px; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--card); color: var(--text); }
    button { cursor: pointer; border: 0; background: var(--primary); color: var(--btn-text); font-weight: 700; }
    button.secondary { background: transparent; color: var(--text); border: 1px solid var(--border); }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .toolbar { display: flex; gap: 12px; flex-wrap: wrap; }

    /* Grid */
    .grid { margin-top: 16px; display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; }
    @media (max-width: 900px){ .grid { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 560px){ .grid { grid-template-columns: repeat(2, 1fr); } }
    .slot { padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: var(--card); display:flex; flex-direction:column; gap:6px; }
    .slot-time { font-weight: 700; }
    .slot.free { border-color: var(--ok-border); background: var(--ok-bg); }
    .slot.busy { border-color: var(--busy-border); background: var(--busy-bg); }
    .slot .meta { font-size: 12px; color: var(--muted); }

    .footer { font-size: 12px; color: var(--muted); margin-top: 12px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="appbar">
      <div class="brand">
        <div class="logo">PENSKE</div>
        <div class="title">Meeting Room Scheduler</div>
      </div>
      <div class="actions">
        <button id="googleSignIn" class="secondary" title="Admin sign in">Admin sign in</button>
        <button id="googleSignOut" class="secondary" title="Sign out" style="display:none">Sign out</button>
      </div>
    </div>

    <div class="card" id="setup">
      <div id="debug" class="footer"></div>
      <div class="toolbar">
        <div>
          <label>Room</label><br />
          <select id="room">
            <option value="tukwila">Tukwila</option>
            <option value="everett">Everett</option>
            <option value="n-kent">N Kent</option>
            <option value="s-kent">S Kent</option>
          </select>
        </div>
        <div>
          <label>Date</label><br />
          <input id="date" type="date" />
        </div>
        <div>
          <label>Slot length</label><br />
          <select id="slotLength">
            <option value="30">30 min</option>
            <option value="60">60 min</option>
          </select>
        </div>
        <div>
          <label>Your display name</label><br />
          <input id="displayName" type="text" placeholder="Enter your name" />
        </div>
        <div>
          <label>&nbsp;</label><br />
          <button id="refresh">Refresh</button>
        </div>
      </div>

      <div class="footer" id="authInfo">Signing in…</div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="toolbar">
        <button id="reserveSelected">Reserve selected</button>
        <button class="secondary" id="releaseSelected">Release mine</button>
        <button class="secondary" id="adminDeleteSelected" style="display:none">Release (admin)</button>
      </div>
      <div id="grid" class="grid"></div>
    </div>

    <!-- Admin Dashboard: read-only list of bookings for this date/room -->
    <div class="card" style="margin-top:16px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong>Bookings (read-only)</strong>
        <button id="exportCsv" class="secondary">Export CSV</button>
      </div>
      <div id="adminList" class="footer">No bookings yet.</div>
    </div>

    <p class="footer">Changes appear in real time on all devices. If two people click the same free slot simultaneously, a Firestore <em>transaction</em> ensures only the first write succeeds.</p>
  </div>

  <!-- Firebase v10+ Modular SDKs from CDN -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>
  <script>
    // =============================
    // Firebase configuration (already filled)
    // =============================
    const firebaseConfig = {
  apiKey: "AIzaSyA_YLnbdGKh1k-_CQfAqgiq4IxnwItcTxg",
  authDomain: "meetingroomscheduler-e5600.firebaseapp.com",
  projectId: "meetingroomscheduler-e5600",
  storageBucket: "meetingroomscheduler-e5600.firebasestorage.app",
  messagingSenderId: "493825332105",
  appId: "1:493825332105:web:836ce32a23ea36f0c54758",
  measurementId: "G-C08DZKQ4VL"
};

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db   = firebase.firestore();

    const els = {
      room: document.getElementById('room'),
      date: document.getElementById('date'),
      slotLength: document.getElementById('slotLength'),
      displayName: document.getElementById('displayName'),
      refresh: document.getElementById('refresh'),
      grid: document.getElementById('grid'),
      reserveSelected: document.getElementById('reserveSelected'),
      releaseSelected: document.getElementById('releaseSelected'),
      adminDeleteSelected: document.getElementById('adminDeleteSelected'),
      authInfo: document.getElementById('authInfo'),
      googleSignIn: document.getElementById('googleSignIn'),
      googleSignOut: document.getElementById('googleSignOut')
    };

    // Default date = today (local)
    const todayISO = new Date().toISOString().slice(0,10);
    els.date.value = todayISO;

    // Sign-in helpers (Google + optional Anonymous fallback)
    const ADMIN_UIDS = [
      // TODO: paste your Google UID here once you sign in and copy it from Firebase Console → Authentication → Users
      // "YOUR_GOOGLE_UID_HERE"
    ];

    function isAdmin(uid){ return ADMIN_UIDS.includes(uid); }

    // Optional anonymous sign-in (still enabled so guests can book)
    auth.signInAnonymously().catch((e) => {
      console.error('Anonymous auth error:', e);
    });
      els.authInfo.textContent = 'Sign-in failed: ' + (e?.message || e);
    });

    let currentUser = null;
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        const name = user.displayName || 'Guest';
        const mail = user.email ? ` <${user.email}>` : '';
        els.authInfo.textContent = `Signed in as ${name}${mail} (uid: ${user.uid.slice(0,6)}…)`;
        els.reserveSelected.disabled = false;
        els.releaseSelected.disabled = false;
        els.refresh.disabled = false;
        els.googleSignIn.style.display = 'none';
        els.googleSignOut.style.display = 'inline-block';
        // Admin button visibility
        els.adminDeleteSelected.style.display = isAdmin(user.uid) ? 'inline-block' : 'none';
        refreshGrid();
      } else {
        els.authInfo.textContent = 'Not signed in';
        els.reserveSelected.disabled = true;
        els.releaseSelected.disabled = true;
        els.refresh.disabled = true;
        els.googleSignIn.style.display = 'inline-block';
        els.googleSignOut.style.display = 'none';
        els.adminDeleteSelected.style.display = 'none';
      }
    });
      } else {
        els.authInfo.textContent = 'Not signed in';
        els.reserveSelected.disabled = true;
        els.releaseSelected.disabled = true;
        els.refresh.disabled = true;
      }
    });

    const START_HOUR = 8;  // 8am
    const END_HOUR   = 18; // 6pm

    function pad2(n){ return n.toString().padStart(2,'0'); }

    function* generateSlots(lengthMin) {
      for (let h=START_HOUR; h<END_HOUR; h++) {
        for (let m=0; m<60; m+=lengthMin) {
          const start = `${pad2(h)}:${pad2(m)}`;
          let endMin = m + lengthMin;
          let endH = h + Math.floor(endMin/60);
          endMin = endMin % 60;
          const end = `${pad2(endH)}:${pad2(endMin)}`;
          yield { start, end, id: `${start}-${end}` };
        }
      }
    }

    function pathFor(roomId, dateISO) {
      return {
        slotsCol: db.collection('rooms').doc(roomId).collection('dates').doc(dateISO).collection('slots'),
        slotDoc: (slotId) => db.collection('rooms').doc(roomId).collection('dates').doc(dateISO).collection('slots').doc(slotId)
      };
    }

    let unsubscribe = null;

    function renderGrid(roomId, dateISO, lengthMin) {
      const dbg = document.getElementById('debug');
      dbg.textContent = `Rendering grid… room=${roomId}, date=${dateISO}, slot=${lengthMin}min`;
      // Clear existing listener
      if (unsubscribe) { unsubscribe(); unsubscribe = null; }
      els.grid.innerHTML = '';

      // Prepare static slot cells
      const map = new Map(); // id -> element
      let slotCount = 0;
      for (const slot of generateSlots(lengthMin)) {
        const div = document.createElement('div');
        div.className = 'slot free';
        div.dataset.id = slot.id;
        div.innerHTML = `
          <div class="slot-time">${slot.start} – ${slot.end}</div>
          <div class="meta">Free</div>
          <label style="display:flex;gap:6px;align-items:center;margin-top:4px">
            <input type="checkbox" class="sel" /> Select
          </label>
        `;
        els.grid.appendChild(div);
        map.set(slot.id, div);
        slotCount++;
      }
      dbg.textContent = `Generated ${slotCount} slots. room=${roomId}, date=${dateISO}, slot=${lengthMin}min`; – ${slot.end}</div>
          <div class="meta">Free</div>
          <label style="display:flex;gap:6px;align-items:center;margin-top:4px">
            <input type="checkbox" class="sel" /> Select
          </label>
        `;
        els.grid.appendChild(div);
        map.set(slot.id, div);
      }

      const { slotsCol } = pathFor(roomId, dateISO);
      unsubscribe = slotsCol.orderBy('start').onSnapshot((snap) => {
        for (const [, el] of map) {
          el.classList.remove('busy');
          el.classList.add('free');
          el.querySelector('.meta').textContent = 'Free';
        }
        const bookings = [];
        snap.forEach((docSnap) => {
          const d = docSnap.data();
          const el = map.get(docSnap.id);
          if (!el) return;
          el.classList.remove('free');
          el.classList.add('busy');
          const by = d.displayName || (d.userId ? d.userId.slice(0,6) : '—');
          el.querySelector('.meta').textContent = `Booked by ${by}`;
          bookings.push({ id: docSnap.id, start: d.start, end: d.end, by });
        });
        renderAdminList(bookings);
      }, (err) => {
        console.error('Firestore listener error:', err);
        document.getElementById('adminList').textContent = 'Error loading bookings: ' + (err?.message || err);
      });
    }

    function getSelections() {
      return Array.from(els.grid.querySelectorAll('.slot input.sel:checked')).map(chk => chk.closest('.slot').dataset.id);
    }

    async function reserveSelected() {
      const roomId = els.room.value;
      const dateISO = els.date.value;
      const lengthMin = parseInt(els.slotLength.value, 10) || 30;
      const { slotDoc } = pathFor(roomId, dateISO);
      const name = els.displayName.value.trim();

      const selected = getSelections();
      if (selected.length === 0) return alert('Select at least one free slot.');

      try {
        for (const sid of selected) {
          await db.runTransaction(async (tx) => {
            const ref = slotDoc(sid);
            const snap = await tx.get(ref);
            if (snap.exists) {
              throw new Error(`Slot ${sid} already booked`);
            }
            const [start, end] = sid.split('-');
            tx.set(ref, {
              start, end,
              userId: auth.currentUser?.uid || null,
              displayName: name || null,
              createdAt: firebase.firestore.FieldValue.serverTimestamp(),
              lengthMin
            });
          });
        }
        els.grid.querySelectorAll('.slot input.sel:checked').forEach(chk => (chk.checked = false));
      } catch (err) {
        alert(err.message);
      }
    }

    async function releaseSelected() {
      const roomId = els.room.value;
      const dateISO = els.date.value;
      const { slotDoc } = pathFor(roomId, dateISO);
      const selected = getSelections();
      if (selected.length === 0) return alert('Select at least one booked slot to release.');

      try {
        for (const sid of selected) {
          await db.runTransaction(async (tx) => {
            const ref = slotDoc(sid);
            const snap = await tx.get(ref);
            if (!snap.exists) return; // already free
            const data = snap.data();
            if (data.userId !== auth.currentUser?.uid) {
              throw new Error(`You can only release your own reservation for slot ${sid}.`);
            }
            tx.delete(ref);
          });
        }
        els.grid.querySelectorAll('.slot input.sel:checked').forEach(chk => (chk.checked = false));
      } catch (err) {
        alert(err.message);
      }
    }

    function refreshGrid(){
      const roomId = els.room.value;
      const dateISO = els.date.value;
      const lengthMin = parseInt(els.slotLength.value, 10) || 30;
      renderGrid(roomId, dateISO, lengthMin);
    }

    els.room.addEventListener('change', refreshGrid);
    els.date.addEventListener('change', refreshGrid);
    els.slotLength.addEventListener('change', refreshGrid);
    els.refresh.addEventListener('click', refreshGrid);
    els.reserveSelected.addEventListener('click', reserveSelected);
    els.releaseSelected.addEventListener('click', releaseSelected);

    // Google sign-in/out (try popup; if blocked, fall back to redirect)
    const provider = new firebase.auth.GoogleAuthProvider();
    els.googleSignIn.addEventListener('click', async (e) => {
      e.preventDefault();
      try {
        await auth.signInWithPopup(provider);
      } catch (err) {
        console.warn('Popup blocked or failed, trying redirect...', err);
        try { await auth.signInWithRedirect(provider); } catch (e2) { alert('Google sign-in failed: ' + (e2?.message || e2)); }
      }
    });
    els.googleSignOut.addEventListener('click', async (e) => {
      e.preventDefault();
      try { await auth.signOut(); } catch (e3) { alert('Sign out failed: ' + (e3?.message || e3)); }
    });('click', async () => {
      try { await auth.signOut(); } catch (e) { alert('Sign out failed: ' + (e?.message || e)); }
    });

    // Admin delete (force delete regardless of owner) — requires rules to allow admin UID
    async function adminDeleteSelected(){
      const user = auth.currentUser;
      if (!user || !isAdmin(user.uid)) return alert('Admin only');
      const roomId = els.room.value;
      const dateISO = els.date.value;
      const { slotDoc } = pathFor(roomId, dateISO);
      const selected = getSelections();
      if (selected.length === 0) return alert('Select at least one booked slot to release.');
      try {
        for (const sid of selected) {
          await db.runTransaction(async (tx) => {
            const ref = slotDoc(sid);
            const snap = await tx.get(ref);
            if (!snap.exists) return; // already free
            tx.delete(ref);
          });
        }
        els.grid.querySelectorAll('.slot input.sel:checked').forEach(chk => (chk.checked = false));
      } catch (err) {
        alert(err.message);
      }
    }
    els.adminDeleteSelected.addEventListener('click', adminDeleteSelected);

    // Admin list renderer & CSV export
    function renderAdminList(items){
      const host = document.getElementById('adminList');
      if (!items || items.length === 0) { host.textContent = 'No bookings yet.'; return; }
      const rows = items
        .sort((a,b)=> a.start.localeCompare(b.start))
        .map(x=>`<tr><td style='padding:8px;border-bottom:1px solid var(--border)'>${x.start}–${x.end}</td><td style='padding:8px;border-bottom:1px solid var(--border)'>${x.by}</td></tr>`) 
        .join('');
      host.innerHTML = `<table style='width:100%;border-collapse:collapse'><thead><tr><th style='text-align:left;padding:8px;border-bottom:1px solid var(--border)'>Time</th><th style='text-align:left;padding:8px;border-bottom:1px solid var(--border)'>Booked by</th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    // Initial grid render (also on DOM ready)
    function domReady(fn){ document.readyState!=='loading' ? fn() : document.addEventListener('DOMContentLoaded', fn); }
    domReady(refreshGrid);

    // Optional: keep displayName in localStorage
    els.displayName.value = localStorage.getItem('mr_display_name') || '';
    els.displayName.addEventListener('change', () => localStorage.setItem('mr_display_name', els.displayName.value));

  </script>

  <!-- =============================
       Firestore Security Rules (copy into Firebase Console ▶ Firestore ▶ Rules)
       These rules:
       * Allow reads to authenticated users
       * Allow slot create only if the slot does not already exist (prevents overwrite)
       * Allow delete only by the original creator (matching userId)
       * Block updates (no overwriting)
     ============================= -->
  <!--
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      function isAuthed() { return request.auth != null; }

      match /rooms/{roomId}/dates/{dateISO}/slots/{slotId} {
        allow read: if isAuthed();

        allow create: if isAuthed() &&
          !exists(/databases/$(database)/documents/rooms/$(roomId)/dates/$(dateISO)/slots/$(slotId)) &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.start is string &&
          request.resource.data.end is string &&
          request.resource.data.createdAt == request.time;

        allow delete: if isAuthed() && resource.data.userId == request.auth.uid;
        allow update: if false; // no overwriting
      }

      // Optional: allow listing rooms/dates documents for UI
      match /rooms/{roomId} { allow read: if isAuthed(); }
      match /rooms/{roomId}/dates/{dateISO} { allow read: if isAuthed(); }
    }
  }
  -->

  <!-- =============================
       Deployment tips
       1) Enable Authentication ▶ Sign-in method ▶ Anonymous (or any SSO you want)
       2) Create Firestore in Production mode
       3) Paste the Rules above
       4) Host this file anywhere (GitHub Pages, Netlify, Vercel). Since it talks directly to Firestore, it works as a static site.
       5) (Optional) Replace Anonymous with Google/Microsoft sign‑in so names/ownership are clearer.
     ============================= -->
</body>
</html>
